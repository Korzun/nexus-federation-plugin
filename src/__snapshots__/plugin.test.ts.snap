// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`plugin \`enableKeyOnInterface\` configured to \`false\` generates the schema with \`key\` only allowing \`OBJECT\` 1`] = `
"### This file was generated by Nexus Schema
### Do not make changes to this file directly


directive @external on FIELD_DEFINITION

directive @key(fields: _FieldSet!) repeatable on OBJECT

directive @override(from: String!) on FIELD_DEFINITION

directive @provides(fields: _FieldSet!) on FIELD_DEFINITION

directive @requires(fields: _FieldSet!) on FIELD_DEFINITION

directive @shareable on FIELD_DEFINITION | OBJECT

type Company @shareable {
  id: ID
  name: String @external
}

type Query {
  test: Boolean
}

type User @key(fields: \\"id email\\") {
  company: Company @provides(fields: \\"name\\")
  email: String @shareable
  id: ID
  name: String
  title: String @external
}

scalar _FieldSet"
`;

exports[`plugin \`enableKeyOnInterface\` configured to \`false\` generates typegen with \`key\` only allowing \`OBJECT\` 1`] = `
"/**
 * This file was generated by Nexus Schema
 * Do not make changes to this file directly
 */


import type { FederationExternalField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/external/field\\"
import type { FederationOverrideField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/override/field\\"
import type { FederationProvidesField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/provides/field\\"
import type { FederationRequiresField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/requires/field\\"
import type { FederationShareableField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/field\\"
import type { FederationKeysObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/keys/object\\"
import type { FederationShareableObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/object\\"




declare global {
  interface NexusGen extends NexusGenTypes {}
}

export interface NexusGenInputs {
}

export interface NexusGenEnums {
}

export interface NexusGenScalars {
  String: string
  Int: number
  Float: number
  Boolean: boolean
  ID: string
  _FieldSet: any
}

export interface NexusGenObjects {
  Company: { // root type
    id?: string | null; // ID
    name?: string | null; // String
  }
  Query: {};
  User: { // root type
    company?: NexusGenRootTypes['Company'] | null; // Company
    email?: string | null; // String
    id?: string | null; // ID
    name?: string | null; // String
    title?: string | null; // String
  }
}

export interface NexusGenInterfaces {
}

export interface NexusGenUnions {
}

export type NexusGenRootTypes = NexusGenObjects

export type NexusGenAllTypes = NexusGenRootTypes & NexusGenScalars

export interface NexusGenFieldTypes {
  Company: { // field return type
    id: string | null; // ID
    name: string | null; // String
  }
  Query: { // field return type
    test: boolean | null; // Boolean
  }
  User: { // field return type
    company: NexusGenRootTypes['Company'] | null; // Company
    email: string | null; // String
    id: string | null; // ID
    name: string | null; // String
    title: string | null; // String
  }
}

export interface NexusGenFieldTypeNames {
  Company: { // field return type name
    id: 'ID'
    name: 'String'
  }
  Query: { // field return type name
    test: 'Boolean'
  }
  User: { // field return type name
    company: 'Company'
    email: 'String'
    id: 'ID'
    name: 'String'
    title: 'String'
  }
}

export interface NexusGenArgTypes {
}

export interface NexusGenAbstractTypeMembers {
}

export interface NexusGenTypeInterfaces {
}

export type NexusGenObjectNames = keyof NexusGenObjects;

export type NexusGenInputNames = never;

export type NexusGenEnumNames = never;

export type NexusGenInterfaceNames = never;

export type NexusGenScalarNames = keyof NexusGenScalars;

export type NexusGenUnionNames = never;

export type NexusGenDirectives = \\"external\\" | \\"key\\" | \\"override\\" | \\"provides\\" | \\"requires\\" | \\"shareable\\"

export interface NexusGenDirectiveArgs {
  external: {
  }
  key: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  override: {
    from:string; // String!
  }
  provides: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  requires: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  shareable: {
  }
}

export type NexusGenObjectsUsingAbstractStrategyIsTypeOf = never;

export type NexusGenAbstractsUsingStrategyResolveType = never;

export type NexusGenFeaturesConfig = {
  abstractTypeStrategies: {
    resolveType: true
    __typename: true
    isTypeOf: false
  }
}

export interface NexusGenTypes {
  context: any;
  inputTypes: NexusGenInputs;
  directives: NexusGenDirectives;
  directiveArgs: NexusGenDirectiveArgs;
  rootTypes: NexusGenRootTypes;
  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;
  argTypes: NexusGenArgTypes;
  fieldTypes: NexusGenFieldTypes;
  fieldTypeNames: NexusGenFieldTypeNames;
  allTypes: NexusGenAllTypes;
  typeInterfaces: NexusGenTypeInterfaces;
  objectNames: NexusGenObjectNames;
  inputNames: NexusGenInputNames;
  enumNames: NexusGenEnumNames;
  interfaceNames: NexusGenInterfaceNames;
  scalarNames: NexusGenScalarNames;
  unionNames: NexusGenUnionNames;
  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];
  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];
  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']
  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];
  abstractTypeMembers: NexusGenAbstractTypeMembers;
  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;
  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;
  features: NexusGenFeaturesConfig;
}


declare global {
  interface NexusGenPluginTypeConfig<TypeName extends string> {
    /**
     * Indicates a combination of fields that can be used to
     * uniquely identify and fetch an object or interface.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keys: ['id'],
     * definition(t) {
     * t.id('id');             // shareable because id is a key field
     * t.string('name');
     * },
     * });
     * \`\`\`
     * [Key - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#key)
     */
    keys?: FederationKeysObject<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * Adding the shareable to an object is equivalent to marking each
     * field on the object shareable.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * shareable: true,
     * definition: (t) => {
     * t.string('name');  // shareable because User is marked shareable
     * t.string('email'); // shareable because User is marked shareable
     * },
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableObject
  }
  interface NexusGenPluginInputTypeConfig<TypeName extends string> {
    
  }
  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {
    /**
     * Marks a field as owned by another service. This allows
     * \`Service A\` to use fields from \`Service B\` while also
     * knowing at runtime the types of that field. For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * definition: (t) => {
     * t.string('email', { external: true });
     * t.list.field('review', { type: 'Review' });
     * },
     * });
     * \`\`\`
     * This type extension in the \`Reviews Service\` extends the
     * \`User\` type from the \`Users Service\`. It extends it for
     * the purpose of adding a new field \`reviews\`, which returns
     * a list of \`Reviews\`.
     * [External - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#external)
     */
    external?: FederationExternalField
    /**
     * Indicates that the current subgraph is taking responsibility
     * for resolving the marked field away from the subgraph
     * specified in the from argument.
     * > Only one subgraph can @override any given field. If
     * > multiple subgraphs attempt to @override the same field, a
     * > composition error occurs.
     * The following example will result in all query plans made to
     * resolve \`User.name\` to be directed to \`Subgraph B\`.
     * \`\`\`ts
     * // in SubgraphA
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name');
     * },
     * });
     * // in SubgraphB
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name', override: 'SubgraphA');
     * },
     * });
     * \`\`\`
     * [Override - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#override)
     */
    override?: FederationOverrideField
    /**
     * Annotates the expected returned fieldset from a field
     * on a base type that is guaranteed to be selectable by the
     * gateway. Given the following example:
     * \`\`\`ts
     * objectType({
     * name: 'Review',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.field('product', { type: 'Product', provides: ['name'] });
     * },
     * });
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) => {
     * t.string('upc', { external: true });
     * t.string('name', { external: true });
     * },
     * });
     * \`\`\`
     * When fetching \`Review.product\` from the Reviews service,
     * it is possible to request the name with the expectation that
     * the Reviews service can provide it when going from review to
     * product. \`Product.name\` is an external field on an external
     * type which is why the local type extension of \`Product\` and
     * annotation of \`name\` is required.
     * [Provides - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#provides)
     */
    provides?: FederationProvidesField<TypeName, FieldName>
    /**
     * Annotates the required input fieldset from a base type
     * for a resolver. It is used to develop a query plan where the
     * required fields may not be needed by the client, but the
     * service may need additional information from other services.
     * For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id', { external: true });
     * t.nullable.string('email', { external: true });
     * t.list.field('reviews', { type: 'Review', requires: ['email'] });
     * },
     * });
     * \`\`\`
     * In this case, the Reviews service adds new capabilities to the
     * User type by providing a list of reviews related to a user. In
     * order to fetch these reviews, the Reviews service needs to
     * know the email of the User from the Users service in order to
     * look up the reviews. This means the reviews field / resolver
     * requires the email field from the base User type.
     * [Requires - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#requires)
     */
    requires?: FederationRequiresField<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * \`\`\`ts
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) =>
     * {
     * t.field('upc', { type: 'UPC' });              // shareable because upc is a key field
     * t.string('name');                             // non-shareable
     * t.string('description', { shareable: true }); // shareable
     * }
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableField
  }
  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {
    
  }
  interface NexusGenPluginSchemaConfig {
  }
  interface NexusGenPluginArgConfig {
    
  }
}"
`;

exports[`plugin \`enableKeyOnInterface\` configured to \`true\` generates the schema with \`key\` allowing \`OBJECT\` and \`INTERFACE\` 1`] = `
"### This file was generated by Nexus Schema
### Do not make changes to this file directly


directive @external on FIELD_DEFINITION

directive @key(fields: _FieldSet!) repeatable on INTERFACE | OBJECT

directive @override(from: String!) on FIELD_DEFINITION

directive @provides(fields: _FieldSet!) on FIELD_DEFINITION

directive @requires(fields: _FieldSet!) on FIELD_DEFINITION

directive @shareable on FIELD_DEFINITION | OBJECT

type Company @shareable {
  id: ID
  name: String @external
}

type Query {
  test: Boolean
}

type User @key(fields: \\"id email\\") {
  company: Company @provides(fields: \\"name\\")
  email: String @shareable
  id: ID
  name: String
  title: String @external
}

scalar _FieldSet"
`;

exports[`plugin \`enableKeyOnInterface\` configured to \`true\` generates typegen with \`key\` allowing \`OBJECT\` and \`INTERFACE\` 1`] = `
"/**
 * This file was generated by Nexus Schema
 * Do not make changes to this file directly
 */


import type { FederationExternalField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/external/field\\"
import type { FederationOverrideField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/override/field\\"
import type { FederationProvidesField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/provides/field\\"
import type { FederationRequiresField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/requires/field\\"
import type { FederationShareableField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/field\\"
import type { FederationKeysObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/keys/object\\"
import type { FederationShareableObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/object\\"




declare global {
  interface NexusGen extends NexusGenTypes {}
}

export interface NexusGenInputs {
}

export interface NexusGenEnums {
}

export interface NexusGenScalars {
  String: string
  Int: number
  Float: number
  Boolean: boolean
  ID: string
  _FieldSet: any
}

export interface NexusGenObjects {
  Company: { // root type
    id?: string | null; // ID
    name?: string | null; // String
  }
  Query: {};
  User: { // root type
    company?: NexusGenRootTypes['Company'] | null; // Company
    email?: string | null; // String
    id?: string | null; // ID
    name?: string | null; // String
    title?: string | null; // String
  }
}

export interface NexusGenInterfaces {
}

export interface NexusGenUnions {
}

export type NexusGenRootTypes = NexusGenObjects

export type NexusGenAllTypes = NexusGenRootTypes & NexusGenScalars

export interface NexusGenFieldTypes {
  Company: { // field return type
    id: string | null; // ID
    name: string | null; // String
  }
  Query: { // field return type
    test: boolean | null; // Boolean
  }
  User: { // field return type
    company: NexusGenRootTypes['Company'] | null; // Company
    email: string | null; // String
    id: string | null; // ID
    name: string | null; // String
    title: string | null; // String
  }
}

export interface NexusGenFieldTypeNames {
  Company: { // field return type name
    id: 'ID'
    name: 'String'
  }
  Query: { // field return type name
    test: 'Boolean'
  }
  User: { // field return type name
    company: 'Company'
    email: 'String'
    id: 'ID'
    name: 'String'
    title: 'String'
  }
}

export interface NexusGenArgTypes {
}

export interface NexusGenAbstractTypeMembers {
}

export interface NexusGenTypeInterfaces {
}

export type NexusGenObjectNames = keyof NexusGenObjects;

export type NexusGenInputNames = never;

export type NexusGenEnumNames = never;

export type NexusGenInterfaceNames = never;

export type NexusGenScalarNames = keyof NexusGenScalars;

export type NexusGenUnionNames = never;

export type NexusGenDirectives = \\"external\\" | \\"key\\" | \\"override\\" | \\"provides\\" | \\"requires\\" | \\"shareable\\"

export interface NexusGenDirectiveArgs {
  external: {
  }
  key: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  override: {
    from:string; // String!
  }
  provides: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  requires: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  shareable: {
  }
}

export type NexusGenObjectsUsingAbstractStrategyIsTypeOf = never;

export type NexusGenAbstractsUsingStrategyResolveType = never;

export type NexusGenFeaturesConfig = {
  abstractTypeStrategies: {
    resolveType: true
    __typename: true
    isTypeOf: false
  }
}

export interface NexusGenTypes {
  context: any;
  inputTypes: NexusGenInputs;
  directives: NexusGenDirectives;
  directiveArgs: NexusGenDirectiveArgs;
  rootTypes: NexusGenRootTypes;
  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;
  argTypes: NexusGenArgTypes;
  fieldTypes: NexusGenFieldTypes;
  fieldTypeNames: NexusGenFieldTypeNames;
  allTypes: NexusGenAllTypes;
  typeInterfaces: NexusGenTypeInterfaces;
  objectNames: NexusGenObjectNames;
  inputNames: NexusGenInputNames;
  enumNames: NexusGenEnumNames;
  interfaceNames: NexusGenInterfaceNames;
  scalarNames: NexusGenScalarNames;
  unionNames: NexusGenUnionNames;
  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];
  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];
  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']
  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];
  abstractTypeMembers: NexusGenAbstractTypeMembers;
  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;
  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;
  features: NexusGenFeaturesConfig;
}


declare global {
  interface NexusGenPluginTypeConfig<TypeName extends string> {
    /**
     * Indicates a combination of fields that can be used to
     * uniquely identify and fetch an object or interface.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keys: ['id'],
     * definition(t) {
     * t.id('id');             // shareable because id is a key field
     * t.string('name');
     * },
     * });
     * \`\`\`
     * [Key - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#key)
     */
    keys?: FederationKeysObject<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * Adding the shareable to an object is equivalent to marking each
     * field on the object shareable.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * shareable: true,
     * definition: (t) => {
     * t.string('name');  // shareable because User is marked shareable
     * t.string('email'); // shareable because User is marked shareable
     * },
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableObject
  }
  interface NexusGenPluginInputTypeConfig<TypeName extends string> {
    
  }
  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {
    /**
     * Marks a field as owned by another service. This allows
     * \`Service A\` to use fields from \`Service B\` while also
     * knowing at runtime the types of that field. For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * definition: (t) => {
     * t.string('email', { external: true });
     * t.list.field('review', { type: 'Review' });
     * },
     * });
     * \`\`\`
     * This type extension in the \`Reviews Service\` extends the
     * \`User\` type from the \`Users Service\`. It extends it for
     * the purpose of adding a new field \`reviews\`, which returns
     * a list of \`Reviews\`.
     * [External - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#external)
     */
    external?: FederationExternalField
    /**
     * Indicates that the current subgraph is taking responsibility
     * for resolving the marked field away from the subgraph
     * specified in the from argument.
     * > Only one subgraph can @override any given field. If
     * > multiple subgraphs attempt to @override the same field, a
     * > composition error occurs.
     * The following example will result in all query plans made to
     * resolve \`User.name\` to be directed to \`Subgraph B\`.
     * \`\`\`ts
     * // in SubgraphA
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name');
     * },
     * });
     * // in SubgraphB
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name', override: 'SubgraphA');
     * },
     * });
     * \`\`\`
     * [Override - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#override)
     */
    override?: FederationOverrideField
    /**
     * Annotates the expected returned fieldset from a field
     * on a base type that is guaranteed to be selectable by the
     * gateway. Given the following example:
     * \`\`\`ts
     * objectType({
     * name: 'Review',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.field('product', { type: 'Product', provides: ['name'] });
     * },
     * });
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) => {
     * t.string('upc', { external: true });
     * t.string('name', { external: true });
     * },
     * });
     * \`\`\`
     * When fetching \`Review.product\` from the Reviews service,
     * it is possible to request the name with the expectation that
     * the Reviews service can provide it when going from review to
     * product. \`Product.name\` is an external field on an external
     * type which is why the local type extension of \`Product\` and
     * annotation of \`name\` is required.
     * [Provides - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#provides)
     */
    provides?: FederationProvidesField<TypeName, FieldName>
    /**
     * Annotates the required input fieldset from a base type
     * for a resolver. It is used to develop a query plan where the
     * required fields may not be needed by the client, but the
     * service may need additional information from other services.
     * For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id', { external: true });
     * t.nullable.string('email', { external: true });
     * t.list.field('reviews', { type: 'Review', requires: ['email'] });
     * },
     * });
     * \`\`\`
     * In this case, the Reviews service adds new capabilities to the
     * User type by providing a list of reviews related to a user. In
     * order to fetch these reviews, the Reviews service needs to
     * know the email of the User from the Users service in order to
     * look up the reviews. This means the reviews field / resolver
     * requires the email field from the base User type.
     * [Requires - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#requires)
     */
    requires?: FederationRequiresField<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * \`\`\`ts
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) =>
     * {
     * t.field('upc', { type: 'UPC' });              // shareable because upc is a key field
     * t.string('name');                             // non-shareable
     * t.string('description', { shareable: true }); // shareable
     * }
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableField
  }
  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {
    
  }
  interface NexusGenPluginSchemaConfig {
  }
  interface NexusGenPluginArgConfig {
    
  }
}"
`;

exports[`plugin \`prefixFieldSet\` configured to \`false\` generates the schema with \`FieldSet\` 1`] = `
"### This file was generated by Nexus Schema
### Do not make changes to this file directly


directive @external on FIELD_DEFINITION

directive @key(fields: FieldSet!) repeatable on OBJECT

directive @override(from: String!) on FIELD_DEFINITION

directive @provides(fields: FieldSet!) on FIELD_DEFINITION

directive @requires(fields: FieldSet!) on FIELD_DEFINITION

directive @shareable on FIELD_DEFINITION | OBJECT

type Company @shareable {
  id: ID
  name: String @external
}

scalar FieldSet

type Query {
  test: Boolean
}

type User @key(fields: \\"id email\\") {
  company: Company @provides(fields: \\"name\\")
  email: String @shareable
  id: ID
  name: String
  title: String @external
}"
`;

exports[`plugin \`prefixFieldSet\` configured to \`false\` generates typegen with \`FieldSet\` 1`] = `
"/**
 * This file was generated by Nexus Schema
 * Do not make changes to this file directly
 */


import type { FederationExternalField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/external/field\\"
import type { FederationOverrideField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/override/field\\"
import type { FederationProvidesField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/provides/field\\"
import type { FederationRequiresField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/requires/field\\"
import type { FederationShareableField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/field\\"
import type { FederationKeysObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/keys/object\\"
import type { FederationShareableObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/object\\"




declare global {
  interface NexusGen extends NexusGenTypes {}
}

export interface NexusGenInputs {
}

export interface NexusGenEnums {
}

export interface NexusGenScalars {
  String: string
  Int: number
  Float: number
  Boolean: boolean
  ID: string
  FieldSet: any
}

export interface NexusGenObjects {
  Company: { // root type
    id?: string | null; // ID
    name?: string | null; // String
  }
  Query: {};
  User: { // root type
    company?: NexusGenRootTypes['Company'] | null; // Company
    email?: string | null; // String
    id?: string | null; // ID
    name?: string | null; // String
    title?: string | null; // String
  }
}

export interface NexusGenInterfaces {
}

export interface NexusGenUnions {
}

export type NexusGenRootTypes = NexusGenObjects

export type NexusGenAllTypes = NexusGenRootTypes & NexusGenScalars

export interface NexusGenFieldTypes {
  Company: { // field return type
    id: string | null; // ID
    name: string | null; // String
  }
  Query: { // field return type
    test: boolean | null; // Boolean
  }
  User: { // field return type
    company: NexusGenRootTypes['Company'] | null; // Company
    email: string | null; // String
    id: string | null; // ID
    name: string | null; // String
    title: string | null; // String
  }
}

export interface NexusGenFieldTypeNames {
  Company: { // field return type name
    id: 'ID'
    name: 'String'
  }
  Query: { // field return type name
    test: 'Boolean'
  }
  User: { // field return type name
    company: 'Company'
    email: 'String'
    id: 'ID'
    name: 'String'
    title: 'String'
  }
}

export interface NexusGenArgTypes {
}

export interface NexusGenAbstractTypeMembers {
}

export interface NexusGenTypeInterfaces {
}

export type NexusGenObjectNames = keyof NexusGenObjects;

export type NexusGenInputNames = never;

export type NexusGenEnumNames = never;

export type NexusGenInterfaceNames = never;

export type NexusGenScalarNames = keyof NexusGenScalars;

export type NexusGenUnionNames = never;

export type NexusGenDirectives = \\"external\\" | \\"key\\" | \\"override\\" | \\"provides\\" | \\"requires\\" | \\"shareable\\"

export interface NexusGenDirectiveArgs {
  external: {
  }
  key: {
    fields:NexusGenScalars['FieldSet']; // FieldSet!
  }
  override: {
    from:string; // String!
  }
  provides: {
    fields:NexusGenScalars['FieldSet']; // FieldSet!
  }
  requires: {
    fields:NexusGenScalars['FieldSet']; // FieldSet!
  }
  shareable: {
  }
}

export type NexusGenObjectsUsingAbstractStrategyIsTypeOf = never;

export type NexusGenAbstractsUsingStrategyResolveType = never;

export type NexusGenFeaturesConfig = {
  abstractTypeStrategies: {
    resolveType: true
    __typename: true
    isTypeOf: false
  }
}

export interface NexusGenTypes {
  context: any;
  inputTypes: NexusGenInputs;
  directives: NexusGenDirectives;
  directiveArgs: NexusGenDirectiveArgs;
  rootTypes: NexusGenRootTypes;
  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;
  argTypes: NexusGenArgTypes;
  fieldTypes: NexusGenFieldTypes;
  fieldTypeNames: NexusGenFieldTypeNames;
  allTypes: NexusGenAllTypes;
  typeInterfaces: NexusGenTypeInterfaces;
  objectNames: NexusGenObjectNames;
  inputNames: NexusGenInputNames;
  enumNames: NexusGenEnumNames;
  interfaceNames: NexusGenInterfaceNames;
  scalarNames: NexusGenScalarNames;
  unionNames: NexusGenUnionNames;
  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];
  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];
  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']
  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];
  abstractTypeMembers: NexusGenAbstractTypeMembers;
  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;
  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;
  features: NexusGenFeaturesConfig;
}


declare global {
  interface NexusGenPluginTypeConfig<TypeName extends string> {
    /**
     * Indicates a combination of fields that can be used to
     * uniquely identify and fetch an object or interface.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keys: ['id'],
     * definition(t) {
     * t.id('id');             // shareable because id is a key field
     * t.string('name');
     * },
     * });
     * \`\`\`
     * [Key - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#key)
     */
    keys?: FederationKeysObject<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * Adding the shareable to an object is equivalent to marking each
     * field on the object shareable.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * shareable: true,
     * definition: (t) => {
     * t.string('name');  // shareable because User is marked shareable
     * t.string('email'); // shareable because User is marked shareable
     * },
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableObject
  }
  interface NexusGenPluginInputTypeConfig<TypeName extends string> {
    
  }
  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {
    /**
     * Marks a field as owned by another service. This allows
     * \`Service A\` to use fields from \`Service B\` while also
     * knowing at runtime the types of that field. For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * definition: (t) => {
     * t.string('email', { external: true });
     * t.list.field('review', { type: 'Review' });
     * },
     * });
     * \`\`\`
     * This type extension in the \`Reviews Service\` extends the
     * \`User\` type from the \`Users Service\`. It extends it for
     * the purpose of adding a new field \`reviews\`, which returns
     * a list of \`Reviews\`.
     * [External - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#external)
     */
    external?: FederationExternalField
    /**
     * Indicates that the current subgraph is taking responsibility
     * for resolving the marked field away from the subgraph
     * specified in the from argument.
     * > Only one subgraph can @override any given field. If
     * > multiple subgraphs attempt to @override the same field, a
     * > composition error occurs.
     * The following example will result in all query plans made to
     * resolve \`User.name\` to be directed to \`Subgraph B\`.
     * \`\`\`ts
     * // in SubgraphA
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name');
     * },
     * });
     * // in SubgraphB
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name', override: 'SubgraphA');
     * },
     * });
     * \`\`\`
     * [Override - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#override)
     */
    override?: FederationOverrideField
    /**
     * Annotates the expected returned fieldset from a field
     * on a base type that is guaranteed to be selectable by the
     * gateway. Given the following example:
     * \`\`\`ts
     * objectType({
     * name: 'Review',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.field('product', { type: 'Product', provides: ['name'] });
     * },
     * });
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) => {
     * t.string('upc', { external: true });
     * t.string('name', { external: true });
     * },
     * });
     * \`\`\`
     * When fetching \`Review.product\` from the Reviews service,
     * it is possible to request the name with the expectation that
     * the Reviews service can provide it when going from review to
     * product. \`Product.name\` is an external field on an external
     * type which is why the local type extension of \`Product\` and
     * annotation of \`name\` is required.
     * [Provides - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#provides)
     */
    provides?: FederationProvidesField<TypeName, FieldName>
    /**
     * Annotates the required input fieldset from a base type
     * for a resolver. It is used to develop a query plan where the
     * required fields may not be needed by the client, but the
     * service may need additional information from other services.
     * For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id', { external: true });
     * t.nullable.string('email', { external: true });
     * t.list.field('reviews', { type: 'Review', requires: ['email'] });
     * },
     * });
     * \`\`\`
     * In this case, the Reviews service adds new capabilities to the
     * User type by providing a list of reviews related to a user. In
     * order to fetch these reviews, the Reviews service needs to
     * know the email of the User from the Users service in order to
     * look up the reviews. This means the reviews field / resolver
     * requires the email field from the base User type.
     * [Requires - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#requires)
     */
    requires?: FederationRequiresField<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * \`\`\`ts
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) =>
     * {
     * t.field('upc', { type: 'UPC' });              // shareable because upc is a key field
     * t.string('name');                             // non-shareable
     * t.string('description', { shareable: true }); // shareable
     * }
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableField
  }
  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {
    
  }
  interface NexusGenPluginSchemaConfig {
  }
  interface NexusGenPluginArgConfig {
    
  }
}"
`;

exports[`plugin \`prefixFieldSet\` configured to \`true\` generates the schema with \`_FieldSet\` 1`] = `
"### This file was generated by Nexus Schema
### Do not make changes to this file directly


directive @external on FIELD_DEFINITION

directive @key(fields: _FieldSet!) repeatable on OBJECT

directive @override(from: String!) on FIELD_DEFINITION

directive @provides(fields: _FieldSet!) on FIELD_DEFINITION

directive @requires(fields: _FieldSet!) on FIELD_DEFINITION

directive @shareable on FIELD_DEFINITION | OBJECT

type Company @shareable {
  id: ID
  name: String @external
}

type Query {
  test: Boolean
}

type User @key(fields: \\"id email\\") {
  company: Company @provides(fields: \\"name\\")
  email: String @shareable
  id: ID
  name: String
  title: String @external
}

scalar _FieldSet"
`;

exports[`plugin \`prefixFieldSet\` configured to \`true\` generates typegen with \`_FieldSet\` 1`] = `
"/**
 * This file was generated by Nexus Schema
 * Do not make changes to this file directly
 */


import type { FederationExternalField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/external/field\\"
import type { FederationOverrideField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/override/field\\"
import type { FederationProvidesField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/provides/field\\"
import type { FederationRequiresField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/requires/field\\"
import type { FederationShareableField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/field\\"
import type { FederationKeysObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/keys/object\\"
import type { FederationShareableObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/object\\"




declare global {
  interface NexusGen extends NexusGenTypes {}
}

export interface NexusGenInputs {
}

export interface NexusGenEnums {
}

export interface NexusGenScalars {
  String: string
  Int: number
  Float: number
  Boolean: boolean
  ID: string
  _FieldSet: any
}

export interface NexusGenObjects {
  Company: { // root type
    id?: string | null; // ID
    name?: string | null; // String
  }
  Query: {};
  User: { // root type
    company?: NexusGenRootTypes['Company'] | null; // Company
    email?: string | null; // String
    id?: string | null; // ID
    name?: string | null; // String
    title?: string | null; // String
  }
}

export interface NexusGenInterfaces {
}

export interface NexusGenUnions {
}

export type NexusGenRootTypes = NexusGenObjects

export type NexusGenAllTypes = NexusGenRootTypes & NexusGenScalars

export interface NexusGenFieldTypes {
  Company: { // field return type
    id: string | null; // ID
    name: string | null; // String
  }
  Query: { // field return type
    test: boolean | null; // Boolean
  }
  User: { // field return type
    company: NexusGenRootTypes['Company'] | null; // Company
    email: string | null; // String
    id: string | null; // ID
    name: string | null; // String
    title: string | null; // String
  }
}

export interface NexusGenFieldTypeNames {
  Company: { // field return type name
    id: 'ID'
    name: 'String'
  }
  Query: { // field return type name
    test: 'Boolean'
  }
  User: { // field return type name
    company: 'Company'
    email: 'String'
    id: 'ID'
    name: 'String'
    title: 'String'
  }
}

export interface NexusGenArgTypes {
}

export interface NexusGenAbstractTypeMembers {
}

export interface NexusGenTypeInterfaces {
}

export type NexusGenObjectNames = keyof NexusGenObjects;

export type NexusGenInputNames = never;

export type NexusGenEnumNames = never;

export type NexusGenInterfaceNames = never;

export type NexusGenScalarNames = keyof NexusGenScalars;

export type NexusGenUnionNames = never;

export type NexusGenDirectives = \\"external\\" | \\"key\\" | \\"override\\" | \\"provides\\" | \\"requires\\" | \\"shareable\\"

export interface NexusGenDirectiveArgs {
  external: {
  }
  key: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  override: {
    from:string; // String!
  }
  provides: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  requires: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  shareable: {
  }
}

export type NexusGenObjectsUsingAbstractStrategyIsTypeOf = never;

export type NexusGenAbstractsUsingStrategyResolveType = never;

export type NexusGenFeaturesConfig = {
  abstractTypeStrategies: {
    resolveType: true
    __typename: true
    isTypeOf: false
  }
}

export interface NexusGenTypes {
  context: any;
  inputTypes: NexusGenInputs;
  directives: NexusGenDirectives;
  directiveArgs: NexusGenDirectiveArgs;
  rootTypes: NexusGenRootTypes;
  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;
  argTypes: NexusGenArgTypes;
  fieldTypes: NexusGenFieldTypes;
  fieldTypeNames: NexusGenFieldTypeNames;
  allTypes: NexusGenAllTypes;
  typeInterfaces: NexusGenTypeInterfaces;
  objectNames: NexusGenObjectNames;
  inputNames: NexusGenInputNames;
  enumNames: NexusGenEnumNames;
  interfaceNames: NexusGenInterfaceNames;
  scalarNames: NexusGenScalarNames;
  unionNames: NexusGenUnionNames;
  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];
  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];
  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']
  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];
  abstractTypeMembers: NexusGenAbstractTypeMembers;
  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;
  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;
  features: NexusGenFeaturesConfig;
}


declare global {
  interface NexusGenPluginTypeConfig<TypeName extends string> {
    /**
     * Indicates a combination of fields that can be used to
     * uniquely identify and fetch an object or interface.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keys: ['id'],
     * definition(t) {
     * t.id('id');             // shareable because id is a key field
     * t.string('name');
     * },
     * });
     * \`\`\`
     * [Key - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#key)
     */
    keys?: FederationKeysObject<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * Adding the shareable to an object is equivalent to marking each
     * field on the object shareable.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * shareable: true,
     * definition: (t) => {
     * t.string('name');  // shareable because User is marked shareable
     * t.string('email'); // shareable because User is marked shareable
     * },
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableObject
  }
  interface NexusGenPluginInputTypeConfig<TypeName extends string> {
    
  }
  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {
    /**
     * Marks a field as owned by another service. This allows
     * \`Service A\` to use fields from \`Service B\` while also
     * knowing at runtime the types of that field. For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * definition: (t) => {
     * t.string('email', { external: true });
     * t.list.field('review', { type: 'Review' });
     * },
     * });
     * \`\`\`
     * This type extension in the \`Reviews Service\` extends the
     * \`User\` type from the \`Users Service\`. It extends it for
     * the purpose of adding a new field \`reviews\`, which returns
     * a list of \`Reviews\`.
     * [External - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#external)
     */
    external?: FederationExternalField
    /**
     * Indicates that the current subgraph is taking responsibility
     * for resolving the marked field away from the subgraph
     * specified in the from argument.
     * > Only one subgraph can @override any given field. If
     * > multiple subgraphs attempt to @override the same field, a
     * > composition error occurs.
     * The following example will result in all query plans made to
     * resolve \`User.name\` to be directed to \`Subgraph B\`.
     * \`\`\`ts
     * // in SubgraphA
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name');
     * },
     * });
     * // in SubgraphB
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name', override: 'SubgraphA');
     * },
     * });
     * \`\`\`
     * [Override - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#override)
     */
    override?: FederationOverrideField
    /**
     * Annotates the expected returned fieldset from a field
     * on a base type that is guaranteed to be selectable by the
     * gateway. Given the following example:
     * \`\`\`ts
     * objectType({
     * name: 'Review',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.field('product', { type: 'Product', provides: ['name'] });
     * },
     * });
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) => {
     * t.string('upc', { external: true });
     * t.string('name', { external: true });
     * },
     * });
     * \`\`\`
     * When fetching \`Review.product\` from the Reviews service,
     * it is possible to request the name with the expectation that
     * the Reviews service can provide it when going from review to
     * product. \`Product.name\` is an external field on an external
     * type which is why the local type extension of \`Product\` and
     * annotation of \`name\` is required.
     * [Provides - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#provides)
     */
    provides?: FederationProvidesField<TypeName, FieldName>
    /**
     * Annotates the required input fieldset from a base type
     * for a resolver. It is used to develop a query plan where the
     * required fields may not be needed by the client, but the
     * service may need additional information from other services.
     * For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id', { external: true });
     * t.nullable.string('email', { external: true });
     * t.list.field('reviews', { type: 'Review', requires: ['email'] });
     * },
     * });
     * \`\`\`
     * In this case, the Reviews service adds new capabilities to the
     * User type by providing a list of reviews related to a user. In
     * order to fetch these reviews, the Reviews service needs to
     * know the email of the User from the Users service in order to
     * look up the reviews. This means the reviews field / resolver
     * requires the email field from the base User type.
     * [Requires - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#requires)
     */
    requires?: FederationRequiresField<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * \`\`\`ts
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) =>
     * {
     * t.field('upc', { type: 'UPC' });              // shareable because upc is a key field
     * t.string('name');                             // non-shareable
     * t.string('description', { shareable: true }); // shareable
     * }
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableField
  }
  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {
    
  }
  interface NexusGenPluginSchemaConfig {
  }
  interface NexusGenPluginArgConfig {
    
  }
}"
`;

exports[`plugin default config generates the schema 1`] = `
"### This file was generated by Nexus Schema
### Do not make changes to this file directly


directive @external on FIELD_DEFINITION

directive @key(fields: _FieldSet!) repeatable on OBJECT

directive @override(from: String!) on FIELD_DEFINITION

directive @provides(fields: _FieldSet!) on FIELD_DEFINITION

directive @requires(fields: _FieldSet!) on FIELD_DEFINITION

directive @shareable on FIELD_DEFINITION | OBJECT

type Company @shareable {
  id: ID
  name: String @external
}

type Query {
  test: Boolean
}

type User @key(fields: \\"id email\\") {
  company: Company @provides(fields: \\"name\\")
  email: String @shareable
  id: ID
  name: String
  title: String @external
}

scalar _FieldSet"
`;

exports[`plugin default config generates typegen 1`] = `
"/**
 * This file was generated by Nexus Schema
 * Do not make changes to this file directly
 */


import type { FederationExternalField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/external/field\\"
import type { FederationOverrideField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/override/field\\"
import type { FederationProvidesField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/provides/field\\"
import type { FederationRequiresField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/requires/field\\"
import type { FederationShareableField } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/field\\"
import type { FederationKeysObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/keys/object\\"
import type { FederationShareableObject } from \\"@korzun/nexus-federation-plugin/dist/esm/type/shareable/object\\"




declare global {
  interface NexusGen extends NexusGenTypes {}
}

export interface NexusGenInputs {
}

export interface NexusGenEnums {
}

export interface NexusGenScalars {
  String: string
  Int: number
  Float: number
  Boolean: boolean
  ID: string
  _FieldSet: any
}

export interface NexusGenObjects {
  Company: { // root type
    id?: string | null; // ID
    name?: string | null; // String
  }
  Query: {};
  User: { // root type
    company?: NexusGenRootTypes['Company'] | null; // Company
    email?: string | null; // String
    id?: string | null; // ID
    name?: string | null; // String
    title?: string | null; // String
  }
}

export interface NexusGenInterfaces {
}

export interface NexusGenUnions {
}

export type NexusGenRootTypes = NexusGenObjects

export type NexusGenAllTypes = NexusGenRootTypes & NexusGenScalars

export interface NexusGenFieldTypes {
  Company: { // field return type
    id: string | null; // ID
    name: string | null; // String
  }
  Query: { // field return type
    test: boolean | null; // Boolean
  }
  User: { // field return type
    company: NexusGenRootTypes['Company'] | null; // Company
    email: string | null; // String
    id: string | null; // ID
    name: string | null; // String
    title: string | null; // String
  }
}

export interface NexusGenFieldTypeNames {
  Company: { // field return type name
    id: 'ID'
    name: 'String'
  }
  Query: { // field return type name
    test: 'Boolean'
  }
  User: { // field return type name
    company: 'Company'
    email: 'String'
    id: 'ID'
    name: 'String'
    title: 'String'
  }
}

export interface NexusGenArgTypes {
}

export interface NexusGenAbstractTypeMembers {
}

export interface NexusGenTypeInterfaces {
}

export type NexusGenObjectNames = keyof NexusGenObjects;

export type NexusGenInputNames = never;

export type NexusGenEnumNames = never;

export type NexusGenInterfaceNames = never;

export type NexusGenScalarNames = keyof NexusGenScalars;

export type NexusGenUnionNames = never;

export type NexusGenDirectives = \\"external\\" | \\"key\\" | \\"override\\" | \\"provides\\" | \\"requires\\" | \\"shareable\\"

export interface NexusGenDirectiveArgs {
  external: {
  }
  key: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  override: {
    from:string; // String!
  }
  provides: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  requires: {
    fields:NexusGenScalars['_FieldSet']; // _FieldSet!
  }
  shareable: {
  }
}

export type NexusGenObjectsUsingAbstractStrategyIsTypeOf = never;

export type NexusGenAbstractsUsingStrategyResolveType = never;

export type NexusGenFeaturesConfig = {
  abstractTypeStrategies: {
    resolveType: true
    __typename: true
    isTypeOf: false
  }
}

export interface NexusGenTypes {
  context: any;
  inputTypes: NexusGenInputs;
  directives: NexusGenDirectives;
  directiveArgs: NexusGenDirectiveArgs;
  rootTypes: NexusGenRootTypes;
  inputTypeShapes: NexusGenInputs & NexusGenEnums & NexusGenScalars;
  argTypes: NexusGenArgTypes;
  fieldTypes: NexusGenFieldTypes;
  fieldTypeNames: NexusGenFieldTypeNames;
  allTypes: NexusGenAllTypes;
  typeInterfaces: NexusGenTypeInterfaces;
  objectNames: NexusGenObjectNames;
  inputNames: NexusGenInputNames;
  enumNames: NexusGenEnumNames;
  interfaceNames: NexusGenInterfaceNames;
  scalarNames: NexusGenScalarNames;
  unionNames: NexusGenUnionNames;
  allInputTypes: NexusGenTypes['inputNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['scalarNames'];
  allOutputTypes: NexusGenTypes['objectNames'] | NexusGenTypes['enumNames'] | NexusGenTypes['unionNames'] | NexusGenTypes['interfaceNames'] | NexusGenTypes['scalarNames'];
  allNamedTypes: NexusGenTypes['allInputTypes'] | NexusGenTypes['allOutputTypes']
  abstractTypes: NexusGenTypes['interfaceNames'] | NexusGenTypes['unionNames'];
  abstractTypeMembers: NexusGenAbstractTypeMembers;
  objectsUsingAbstractStrategyIsTypeOf: NexusGenObjectsUsingAbstractStrategyIsTypeOf;
  abstractsUsingStrategyResolveType: NexusGenAbstractsUsingStrategyResolveType;
  features: NexusGenFeaturesConfig;
}


declare global {
  interface NexusGenPluginTypeConfig<TypeName extends string> {
    /**
     * Indicates a combination of fields that can be used to
     * uniquely identify and fetch an object or interface.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keys: ['id'],
     * definition(t) {
     * t.id('id');             // shareable because id is a key field
     * t.string('name');
     * },
     * });
     * \`\`\`
     * [Key - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#key)
     */
    keys?: FederationKeysObject<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * Adding the shareable to an object is equivalent to marking each
     * field on the object shareable.
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * shareable: true,
     * definition: (t) => {
     * t.string('name');  // shareable because User is marked shareable
     * t.string('email'); // shareable because User is marked shareable
     * },
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableObject
  }
  interface NexusGenPluginInputTypeConfig<TypeName extends string> {
    
  }
  interface NexusGenPluginFieldConfig<TypeName extends string, FieldName extends string> {
    /**
     * Marks a field as owned by another service. This allows
     * \`Service A\` to use fields from \`Service B\` while also
     * knowing at runtime the types of that field. For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * definition: (t) => {
     * t.string('email', { external: true });
     * t.list.field('review', { type: 'Review' });
     * },
     * });
     * \`\`\`
     * This type extension in the \`Reviews Service\` extends the
     * \`User\` type from the \`Users Service\`. It extends it for
     * the purpose of adding a new field \`reviews\`, which returns
     * a list of \`Reviews\`.
     * [External - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#external)
     */
    external?: FederationExternalField
    /**
     * Indicates that the current subgraph is taking responsibility
     * for resolving the marked field away from the subgraph
     * specified in the from argument.
     * > Only one subgraph can @override any given field. If
     * > multiple subgraphs attempt to @override the same field, a
     * > composition error occurs.
     * The following example will result in all query plans made to
     * resolve \`User.name\` to be directed to \`Subgraph B\`.
     * \`\`\`ts
     * // in SubgraphA
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name');
     * },
     * });
     * // in SubgraphB
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id');
     * t.nullable.string('name', override: 'SubgraphA');
     * },
     * });
     * \`\`\`
     * [Override - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#override)
     */
    override?: FederationOverrideField
    /**
     * Annotates the expected returned fieldset from a field
     * on a base type that is guaranteed to be selectable by the
     * gateway. Given the following example:
     * \`\`\`ts
     * objectType({
     * name: 'Review',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.field('product', { type: 'Product', provides: ['name'] });
     * },
     * });
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) => {
     * t.string('upc', { external: true });
     * t.string('name', { external: true });
     * },
     * });
     * \`\`\`
     * When fetching \`Review.product\` from the Reviews service,
     * it is possible to request the name with the expectation that
     * the Reviews service can provide it when going from review to
     * product. \`Product.name\` is an external field on an external
     * type which is why the local type extension of \`Product\` and
     * annotation of \`name\` is required.
     * [Provides - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#provides)
     */
    provides?: FederationProvidesField<TypeName, FieldName>
    /**
     * Annotates the required input fieldset from a base type
     * for a resolver. It is used to develop a query plan where the
     * required fields may not be needed by the client, but the
     * service may need additional information from other services.
     * For example:
     * \`\`\`ts
     * objectType({
     * name: 'User',
     * keyFields: ['id'],
     * definition: (t) => {
     * t.id('id', { external: true });
     * t.nullable.string('email', { external: true });
     * t.list.field('reviews', { type: 'Review', requires: ['email'] });
     * },
     * });
     * \`\`\`
     * In this case, the Reviews service adds new capabilities to the
     * User type by providing a list of reviews related to a user. In
     * order to fetch these reviews, the Reviews service needs to
     * know the email of the User from the Users service in order to
     * look up the reviews. This means the reviews field / resolver
     * requires the email field from the base User type.
     * [Requires - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#requires)
     */
    requires?: FederationRequiresField<TypeName>
    /**
     * Indicates that every field on an object can be resolved
     * by multiple subgraphs. Any subgraph that includes a shareable
     * field can potentially resolve a query for that field. To successfully
     * compose, a field must have the same shareability mode (either
     * shareable or non-shareable) across all subgraphs.
     * \`\`\`ts
     * objectType({
     * name: 'Product',
     * keyFields: ['upc'],
     * definition: (t) =>
     * {
     * t.field('upc', { type: 'UPC' });              // shareable because upc is a key field
     * t.string('name');                             // non-shareable
     * t.string('description', { shareable: true }); // shareable
     * }
     * });
     * \`\`\`
     * [Sharable - Apollo Federation 2.0 Subgraph Spec](https://www.apollographql.com/docs/federation/federated-types/federated-directives#shareable)
     */
    shareable?: FederationShareableField
  }
  interface NexusGenPluginInputFieldConfig<TypeName extends string, FieldName extends string> {
    
  }
  interface NexusGenPluginSchemaConfig {
  }
  interface NexusGenPluginArgConfig {
    
  }
}"
`;
